N = 443
p = 3
q = 2**16
d = 2

Bs = 138
Bt = 46

# Set up the rings 
R.<x> = ZZ[]
R = R.quotient( x^N -1 );
Rp = GF(p)[x].quotient( x^N -1 )
Rq = GF(q)[x].quotient( x^N -1 )

x = R.gen()

from random import shuffle, randint

# To make a random polynomial for f and g. 
# This is a very bad way to do it, but it's easy
def gen_ternary( degree, n, even):
    l = [0] * (degree - 2*n)
    for i in range (n):
        l.append(1)
        l.append(-1)
    if not even:
        l.append( 1 ) # add one extra 1 to be a part of T( n+1, n )
    shuffle( l )
    print(l)
    return R(l)

def centerlift( poly, m ):
    coeff = poly.list()
    lifted_coeff = map( lambda a: Mod(a, m).lift_centered(), coeff )
    return R(lifted_coeff)

# Key generation is similar to NTRU, but with f = pF
# .. It also looks like g can be sampled from R(p/2) instead of R(1)
def gen_key():
    F = gen_ternary(N, d, False)
    g = gen_ternary(N, d, False)
    f = p * F
    # The private key is then f, g

    # And the public key is the same as NTRUEncrypt
    Fq = Rq(f) ^ -1
    h = Fq * g
    return ((f, g), h)

# The message is the same as the message for NTRUSign (integers though)
# Basically, a message in R(p/2)
# for example, 
sp = R([4,7,10,-6,11,11,6,-6,9,-9,3])
tp = R([-7,11,11,1,-3,-7,-2,0,-3,9,5])

# Helper for max norm
def max_norm( a ):
    return max( [abs(c) for c in a.list()] )

# One more helper for uniform sampling (inclusive)
def unif_vec( max_val ):
    return [randint(-max_val, max_val) for _ in range(N)]

# This is the tricky part - actually doing the signature
# This returns s, p ( the signature)
# And also a * f, a * g (parameters needed for sampling)
def cantidate_sig( sp, tp, g, f, h ):
    # The literature disagrees on the exact space to sample this next 
    # point from +- 1/2
    A = ( q - p ) // (2 * p)
    # Sample from that range 
    r = R(unif_vec( A ))
    s0 = sp + p * r
    t0 = centerlift( Rq(h * s0), q )
    g_inv = Rp(g) ^ -1
    # And this gives us the vector location of (s, t)
    a = centerlift( g_inv * (tp - t0), p )
    # Then finding our cantidate s and t is easy
    s = s0 + a * f
    t = t0 + a * g
    return (s, t, a * f, a * g)

def sign( tp, sp, g, f, h ):
    i = 0
    while True:
        (s, t, af, ag) = cantidate_sig( sp, tp, g, f, h )
        i += 1
        print "Cantidate_sig is {}, {}".format( s.list(), t.list() )
        print "max_norm( a * f ) = {}".format( max_norm(af) )
        print "max_norm( a * g ) = {}".format( max_norm(ag) )
        print "max_norm( s ) = {}".format( max_norm(s) )
        print "max_norm( t ) = {}".format( max_norm(t) )
        if ( max_norm( af ) <= Bs and max_norm( ag ) <= Bt and
                max_norm( s ) <= q/2 - Bs and max_norm( t ) <= q/2 - Bt ):
            print "Found signature after sampling {} total".format( i )
            return (s, t)

def verify( sp, tp, s, t, f, g, h ):
    # Verify it is a member of the NTRU lattice
    if Rq(t) != Rq(h * s):
        print "Signature is not a member of the NTRU lattice!"
        return False
    # Verify length (i.e. it's close enough without being too close
    if max_norm(s) > q/2 - Bs or max_norm(t) > q/2 - Bt:
        print "Signature doesn't meet norm requirements."
        return False
    # Verify that the modularity requirements hold
    if Rp(sp) != R(s) or Rp(tp) != R(t):
        print "Signature fails modularity requirements."
        return False
    # If we've made it this far, then it's valid
    return True

# Sample usage:
((f, g), h) = gen_key()

print("f = {}".format(f))
print("g = {}".format(g))
print("h = {}".format(h))

#given sp, tp as above (generated as part of the signature)
sp = R([4,7,10,-6,11,11,6,-6,9,-9,3])
tp = R([-7,11,11,1,-3,-7,-2,0,-3,9,5])


# The signature is s, t generated by the sign function
# In reality, we need only publish s, since t = s * h (mod q)
(s, t) = sign( tp, sp, g, f, h )

# We can then verify the signature
verified = verify( sp, tp, s, t, f, g, h )
print "Passed verification? = {}".format( verified )
